namespace Evaluator
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;

    using Antlr4.Runtime;

    using Evaluator.AutoGeneratedByGrammar;

    public class EvaluatorVisitor : EvaluatorBaseVisitor<Value>
    {
        private const double MinValue = 0.0000000001;

        private readonly Dictionary<string, Func<double, double>> functionsByName;
        private readonly Dictionary<string, object> variableToValue;

        public EvaluatorVisitor()
            : this(new Dictionary<string, object>())
        {
        }

        public EvaluatorVisitor(Dictionary<string, object> variableToValue)
        {
            this.variableToValue = variableToValue;
            this.functionsByName = new Dictionary<string, Func<double, double>>()
                {
                    {"abs", Math.Abs}
                };
        }

        public override Value VisitChangeSign(EvaluatorParser.ChangeSignContext context)
        {
            return new Value(-1 * this.GetDouble(this.Visit(context.expr())));
        }

        public override Value VisitNot(EvaluatorParser.NotContext context)
        {
            return new Value(!this.GetBool(this.Visit(context.expr())));
        }

        public override Value VisitPower(EvaluatorParser.PowerContext context)
        {
            return new Value(this.VisitBinaryOperation(context, EvaluatorParser.POW));
        }

        public override Value VisitMultOrDivOrModExpr(EvaluatorParser.MultOrDivOrModExprContext context)
        {
            return new Value(this.VisitBinaryOperation(context, context.op.Type));
        }

        public override Value VisitPlusOrMinusExpr(EvaluatorParser.PlusOrMinusExprContext context)
        {
            return new Value(this.VisitBinaryOperation(context, context.op.Type));
        }

        private double VisitBinaryOperation(ParserRuleContext context, int op)
        {
            var left = this.GetDouble(this.WalkLeft(context));
            var right = this.GetDouble(this.WalkRight(context));

            switch (op)
            {
                case EvaluatorParser.PLUS:
                    return left + right;
                case EvaluatorParser.MINUS:
                    return left - right;
                case EvaluatorParser.MULT:
                    return left * right;
                case EvaluatorParser.DIV:
                    return left / right;
                case EvaluatorParser.MOD:
                    return left % right;
                case EvaluatorParser.POW:
                    return Math.Pow(left, right);
                default:
                    throw new EvaluationException("Invalid arithmetic operator !");
            }
        }

        public override Value VisitRelationalExpr(EvaluatorParser.RelationalExprContext context)
        {
            return new Value(this.VisitRelationalExpr(context, context.op.Type));
        }

        private bool VisitRelationalExpr(ParserRuleContext context, int op)
        {
            var left = this.GetDouble(this.WalkLeft(context));
            var right = this.GetDouble(this.WalkRight(context));

            switch (op)
            {
                case EvaluatorParser.GE:
                    return left >= right;
                case EvaluatorParser.GT:
                    return left > right;
                case EvaluatorParser.LE:
                    return left <= right;
                case EvaluatorParser.LT:
                    return left < right;
                default:
                    throw new EvaluationException("Invalid relational operator !");
            }
        }

        public override Value VisitEqualityExpr(EvaluatorParser.EqualityExprContext context)
        {
            return new Value(this.VisitEqualityExpr(context, context.op.Type));
        }

        private bool VisitEqualityExpr(ParserRuleContext context, int op)
        {
            var left = this.WalkLeft(context);
            var right = this.WalkRight(context);

            switch (op)
            {
                case EvaluatorParser.EQ:
                    return left.IsDouble() && right.IsDouble()
                        ? Math.Abs((double)left.value - (double)right.value) < MinValue
                        : left.value.Equals(right.value);
                case EvaluatorParser.NE:
                    return left.IsDouble() && right.IsDouble()
                        ? Math.Abs((double)left.value - (double)right.value) >= MinValue
                        : !left.value.Equals(right.value);
                default:
                    throw new EvaluationException("Invalid equality operator !");
            }
        }

        public override Value VisitAndExpr(EvaluatorParser.AndExprContext context)
        {
            var left = this.GetBool(this.WalkLeft(context));
            var right = this.GetBool(this.WalkRight(context));

            return new Value(left && right);
        }

        public override Value VisitOrExpr(EvaluatorParser.OrExprContext context)
        {
            var left = this.GetBool(this.WalkLeft(context));
            var right = this.GetBool(this.WalkRight(context));

            return new Value(left || right);
        }

        public override Value VisitFunction(EvaluatorParser.FunctionContext context)
        {
            var functionName = context.funcName().GetText();
            Func<double, double> function;
            if (!this.functionsByName.TryGetValue(functionName.ToLower(), out function))
            {
                throw new EvaluationException(string.Format("Cannot find function '{0}'", functionName));
            }

            var parameter = this.Visit(context.expr());
            double doubleValue;
            if (!parameter.TryGetDouble(out doubleValue))
            {
                throw new EvaluationException(string.Format("For function '{0}', parameter has to be a double", functionName));
            }

            return new Value(function(doubleValue));
        }

        public override Value VisitBraces(EvaluatorParser.BracesContext context)
        {
            return this.Visit(context.expr());
        }

        public override Value VisitNumber(EvaluatorParser.NumberContext context)
        {
            return new Value(Convert.ToDouble(context.num().GetText(), CultureInfo.InvariantCulture));
        }

        public override Value VisitBoolean(EvaluatorParser.BooleanContext context)
        {
            return new Value(Convert.ToBoolean(context.@bool().GetText().ToLower()));
        }

        public override Value VisitVariable(EvaluatorParser.VariableContext context)
        {
            var variableName = context.var().GetText();
            object value;
            if (!this.variableToValue.TryGetValue(variableName, out value))
            {
                throw new EvaluationException(string.Format("Cannot find variable '{0}'", variableName));
            }

            if (value is int)
                value = Convert.ToDouble(value, CultureInfo.InvariantCulture);

            return new Value(value);
        }

        public override Value VisitString(EvaluatorParser.StringContext context)
        {
            var str = context.str().GetText();

            // Remove quote
            str = str.Substring(1, str.Length - 2).Replace("\"\"", "\""); ;

            return new Value(str);
        }

        #region Constants
        public override Value VisitContantePi(EvaluatorParser.ContantePiContext context)
        {
            return new Value(Math.PI);
        }
        #endregion


        #region Helper
        private Value WalkLeft(ParserRuleContext context)
        {
            return this.Visit(context.GetRuleContext<ParserRuleContext>(0));
        }

        private Value WalkRight(ParserRuleContext context)
        {
            return this.Visit(context.GetRuleContext<ParserRuleContext>(1));
        }

        private double GetDouble(Value Value)
        {
            double doubleValue;
            if (!Value.TryGetDouble(out doubleValue))
            {
                throw new EvaluationException("Double attended");
            }
            return doubleValue;
        }

        private bool GetBool(Value Value)
        {
            bool boolValue;
            if (!Value.TryGetBool(out boolValue))
            {
                throw new EvaluationException("Bool attended");
            }
            return boolValue;
        }

        private string GetString(Value Value)
        {
            string stringValue;
            if (!Value.TryGetString(out stringValue))
            {
                throw new EvaluationException("String attended");
            }
            return stringValue;
        }
        #endregion
    }
}